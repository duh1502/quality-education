{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "864705d0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Criar DataFrames para armazenar os resultados obtidos por cada modelo testado e facilitar a comparação\n",
    "df_results = pd.DataFrame(columns=['Modelo', 'R2', \"mean_absolute_error\",\"rmse\", \"mean_squared_error\"])\n",
    "#df_results = pd.read_csv('df_results_models.csv')\n",
    "df_predicts_train = pd.DataFrame()\n",
    "df_predicts_final = pd.DataFrame()\n",
    "\n",
    "model_xgb = XGBRegressor(colsample_bytree=0.7, \n",
    "                          #gamma=0.0468,\n",
    "                          learning_rate=0.05, \n",
    "                          max_depth=3,\n",
    "                          #min_child_weight=2.0, \n",
    "                          n_estimators=200,\n",
    "                          reg_alpha=0.5, \n",
    "                          reg_lambda=0.88,\n",
    "                          subsample=1,\n",
    "                          random_state=8, \n",
    "                          nthread = -1\n",
    "                        )\n",
    "\n",
    "#Lista de modelos para treinamento\n",
    "regressores = {\n",
    "    #'XGBRegressor': model_xgb\n",
    "    'Lasso': Lasso(random_state=18)\n",
    "    #,'SGDRegressor': SGDRegressor(random_state=18)#alpha=0.00005,\n",
    "    #,'ElasticNet': ElasticNet(alpha=0.0005,random_state=8)\n",
    " #,'GradientBoosting': GradientBoostingRegressor(learning_rate=0.04,n_estimators=100,random_state=8)\n",
    "    #,'Ridge': Ridge( solver=\"cholesky\",random_state=8)\n",
    "    #,'AdaBoostRegressor': AdaBoostRegressor(n_estimators=500,learning_rate=0.05,random_state=8)\n",
    "    #'CatBoostRegressor': CatBoostRegressor(verbose=False,random_state=8)#(iterations=200,learning_rate=0.05,depth=2, l2_leaf_reg= 0.2,)\n",
    "}\n",
    "\n",
    "modelos_treinados = {}\n",
    "\n",
    "#['NU_NOTA_CN', 'NU_NOTA_CH', 'NU_NOTA_LC', 'NU_NOTA_MT', 'NU_NOTA_REDACAO']\n",
    "# Percorrer a lista de modelos, efetuar o treinamento e armazenar os resultados de avaliação nos DataFrames apropriados\n",
    "for no_modelo, modelo in regressores.items():\n",
    "  for target in ['NU_NOTA_CN', 'NU_NOTA_CH', 'NU_NOTA_LC', 'NU_NOTA_MT', 'NU_NOTA_REDACAO']:\n",
    "    t_inicio = time.time()\n",
    "    no_modelo_ = no_modelo + '_' + target + '_MODEL'\n",
    "    print(no_modelo_)\n",
    "    dict_result = {}\n",
    "    \n",
    "    #Criar o pipeline com o modelo\n",
    "    my_pipeline = Pipeline(\n",
    "        steps=[\n",
    "                ('transform', EnemTransform(colunas_categoricas )),\n",
    "              #('scaler',StandardScaler()),\n",
    "              #('PCA',PCA()),\n",
    "                ('model', modelo)\n",
    "        ]\n",
    " )\n",
    "\n",
    "    #Treinar o pipeline\n",
    "    model_to_deploy = my_pipeline.fit(X_train, y_train[target])\n",
    "\n",
    "    # Save the trained model to disk\n",
    "    file_name = f'pipeline_{no_modelo_}.pkl'\n",
    "    joblib.dump(my_pipeline, file_name, compress = 1)\n",
    "\n",
    "    #Calcular dados de treino\n",
    "    y_pred = my_pipeline.predict(X_test)\n",
    "\n",
    "    # Montar dicionários com avaliações\n",
    "    dict_result['Regressor'] = no_modelo\n",
    "    dict_result['Modelo'] = no_modelo_\n",
    "    dict_result['R2'] = r2_score(y_test[target], y_pred)\n",
    "    dict_result[\"mean_absolute_error\"] = mean_absolute_error(y_test[target], y_pred)\n",
    "    dict_result[\"rmse\"] = mean_squared_error(y_test[target], y_pred, squared=False)\n",
    "    dict_result[\"mean_squared_error\"] = mean_squared_error(y_test[target], y_pred)\n",
    "\n",
    "    # Adicionar dados para o DataFrame de resultados\n",
    "    df_results = df_results.append(dict_result, ignore_index=True)\n",
    "    df_results.drop_duplicates(inplace=True)\n",
    "\n",
    "    #Salvar DataFrame no disco\n",
    "    df_results.to_csv('df_results_models.csv', index=False)\n",
    "\n",
    "    #Verificar o tempo de execução\n",
    "    t_final = time.time()\n",
    "    minutos, segundos = divmod(round((t_final - t_inicio),0),60)\n",
    "    print(\"Tempo total:\",str(int(minutos)), \"minutos e\",str(int(segundos)),\"segundos!\")\n",
    "    print('-'*100)\n",
    "#Calcular a média do RMSE para o modelo treinado\n",
    "df_results[(df_results['Regressor'] == 'Lasso') & \n",
    "           (df_results['Modelo'].str.endswith('_MODEL'))]['rmse'].mean()\n",
    "#df_results.drop(df_results[df_results['Modelo'].str.endswith('_MODEL')].index, inplace=True)\n",
    "#df_results.to_csv('df_results_models.csv', index=False)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
